# Generated by Django 5.0.6 on 2025-08-09 20:19

from django.db import migrations, models


def set_provider_for_existing_clips(apps, schema_editor):
    """Set provider='r2' for existing VideoClips with r2_file"""
    VideoClip = apps.get_model("workouts", "VideoClip")
    # Update all clips with r2_file to use r2 provider
    VideoClip.objects.filter(r2_file__isnull=False).exclude(r2_file='').update(provider='r2')


def reverse_set_provider(apps, schema_editor):
    """Reverse migration - no action needed"""


def safe_drop_weekly_lesson_constraint(apps, schema_editor):
    """Safely drop legacy unique_weekly_lesson constraint if it exists"""
    vendor = schema_editor.connection.vendor
    
    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            try:
                cursor.execute("""
                    ALTER TABLE weekly_lessons 
                    DROP CONSTRAINT IF EXISTS unique_weekly_lesson
                """)
            except Exception:
                # Constraint doesn't exist or table doesn't exist - ignore
                pass
        # SQLite doesn't need this - unique_together handles it


def safe_add_exercise_columns(apps, schema_editor):
    Exercise = apps.get_model("workouts", "Exercise")
    table = Exercise._meta.db_table  # обычно 'exercises'
    qn = schema_editor.quote_name
    vendor = schema_editor.connection.vendor

    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            def col_exists(name: str) -> bool:
                cursor.execute("""
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_name = %s AND column_name = %s
                """, [table.split(".")[-1], name])
                return cursor.fetchone() is not None

            if not col_exists("equipment"):
                cursor.execute("""
                    ALTER TABLE {qn(table)}
                    ADD COLUMN IF NOT EXISTS equipment varchar(50)
                    DEFAULT 'bodyweight' NOT NULL
                """)
            if not col_exists("poster_image"):
                cursor.execute("""
                    ALTER TABLE {qn(table)}
                    ADD COLUMN IF NOT EXISTS poster_image varchar(100)
                """)
        else:
            # dev/SQLite fallback
            try:
                cursor.execute(f"PRAGMA table_info({table})")
                cols = [r[1] for r in cursor.fetchall()]
                if "equipment" not in cols:
                    cursor.execute(f"ALTER TABLE {qn(table)} ADD COLUMN equipment varchar(50)")
                    cursor.execute(
                        f"UPDATE {qn(table)} SET equipment='bodyweight' WHERE equipment IS NULL"
                    )
                if "poster_image" not in cols:
                    cursor.execute(f"ALTER TABLE {qn(table)} ADD COLUMN poster_image varchar(100)")
            except Exception:
                pass


def safe_add_videoclip_columns(apps, schema_editor):
    VideoClip = apps.get_model("workouts", "VideoClip")
    table = VideoClip._meta.db_table  # обычно 'video_clips'
    qn = schema_editor.quote_name
    vendor = schema_editor.connection.vendor

    # Define VideoClip columns to add safely
    columns_to_add = [
        ('is_placeholder', 'boolean DEFAULT FALSE'),
        ('playback_id', 'varchar(64)'),
        ('provider', "varchar(16) DEFAULT 'r2'"),
        ('r2_archetype', 'varchar(20)'),
        ('r2_file', 'varchar(100)'),
        ('r2_kind', "varchar(20) DEFAULT 'instruction'"),
        ('script_text', 'text'),
        ('stream_uid', 'varchar(64)'),
    ]

    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            def col_exists(name: str) -> bool:
                cursor.execute("""
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_name = %s AND column_name = %s
                """, [table.split(".")[-1], name])
                return cursor.fetchone() is not None

            for col_name, col_definition in columns_to_add:
                if not col_exists(col_name):
                    cursor.execute("""
                        ALTER TABLE {qn(table)}
                        ADD COLUMN {col_name} {col_definition}
                    """)
        else:
            # dev/SQLite fallback
            try:
                cursor.execute(f"PRAGMA table_info({table})")
                existing_cols = [r[1] for r in cursor.fetchall()]
                
                for col_name, col_definition in columns_to_add:
                    if col_name not in existing_cols:
                        # Simplify column definitions for SQLite
                        sqlite_def = col_definition.replace('boolean DEFAULT FALSE', 'boolean')
                        sqlite_def = sqlite_def.replace("varchar(16) DEFAULT 'r2'", 'varchar(16)')
                        sqlite_def = sqlite_def.replace("varchar(20) DEFAULT 'instruction'", 'varchar(20)')
                        
                        cursor.execute(f"ALTER TABLE {qn(table)} ADD COLUMN {col_name} {sqlite_def}")
                        
                        # Set defaults separately for SQLite
                        if 'DEFAULT FALSE' in col_definition:
                            cursor.execute(f"UPDATE {qn(table)} SET {col_name} = 0 WHERE {col_name} IS NULL")
                        elif "DEFAULT 'r2'" in col_definition:
                            cursor.execute(f"UPDATE {qn(table)} SET {col_name} = 'r2' WHERE {col_name} IS NULL")
                        elif "DEFAULT 'instruction'" in col_definition:
                            cursor.execute(f"UPDATE {qn(table)} SET {col_name} = 'instruction' WHERE {col_name} IS NULL")
            except Exception:
                pass


def safe_alter_videoclip_unique_together(apps, schema_editor):
    """Safely alter VideoClip unique_together constraint"""
    VideoClip = apps.get_model("workouts", "VideoClip")
    table = VideoClip._meta.db_table
    vendor = schema_editor.connection.vendor
    
    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            # Check if old constraint exists and drop it
            cursor.execute("""
                SELECT COUNT(*)
                FROM pg_constraint c
                JOIN pg_class t ON c.conrelid = t.oid
                WHERE t.relname = %s AND c.contype = 'u'
                AND pg_get_constraintdef(c.oid) LIKE '%%exercise_id%%type%%archetype%%model_name%%reminder_text%%'
            """, [table])
            
            old_constraint_exists = cursor.fetchone()[0] > 0
            
            if old_constraint_exists:
                try:
                    cursor.execute("""
                        ALTER TABLE {table}
                        DROP CONSTRAINT video_clips_exercise_id_type_archetype_model_name_reminder_text_key
                    """)
                except Exception:
                    pass
            
            # Check if new constraint already exists
            cursor.execute("""
                SELECT COUNT(*)
                FROM pg_constraint c
                JOIN pg_class t ON c.conrelid = t.oid
                WHERE t.relname = %s AND c.contype = 'u'
                AND pg_get_constraintdef(c.oid) LIKE '%%exercise_id%%r2_kind%%r2_archetype%%model_name%%reminder_text%%'
            """, [table])
            
            new_constraint_exists = cursor.fetchone()[0] > 0
            
            if not new_constraint_exists:
                try:
                    cursor.execute("""
                        ALTER TABLE {table}
                        ADD CONSTRAINT video_clips_exercise_id_r2_kind_r2_archetype_model_name_reminder_text_key
                        UNIQUE (exercise_id, r2_kind, r2_archetype, model_name, reminder_text)
                    """)
                except Exception:
                    pass
        else:
            # SQLite - unique_together is handled by Django automatically
            pass


def safe_add_videoclip_indexes(apps, schema_editor):
    """Safely add VideoClip indexes (may already exist in production)"""
    VideoClip = apps.get_model("workouts", "VideoClip")
    table = VideoClip._meta.db_table
    vendor = schema_editor.connection.vendor
    qn = schema_editor.quote_name
    
    # Define indexes to add safely (name, fields)
    indexes_to_add = [
        ('video_clips_exercis_1e5613_idx', ['exercise_id', 'r2_kind', 'r2_archetype']),
        ('video_clips_r2_kind_d2e4dd_idx', ['r2_kind', 'r2_archetype']), 
        ('video_clips_is_acti_9705f9_idx', ['is_active', 'r2_kind']),
    ]
    
    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            def index_exists(index_name: str) -> bool:
                cursor.execute("""
                    SELECT 1
                    FROM pg_indexes
                    WHERE tablename = %s AND indexname = %s
                """, [table, index_name])
                return cursor.fetchone() is not None

            for index_name, fields in indexes_to_add:
                if not index_exists(index_name):
                    try:
                        quoted_fields = [qn(field) for field in fields]
                        fields_str = ', '.join(quoted_fields)
                        sql = f'CREATE INDEX IF NOT EXISTS {qn(index_name)} ON {qn(table)} ({fields_str})'
                        cursor.execute(sql)
                    except Exception:
                        pass
        else:
            # SQLite - use simpler approach
            for index_name, fields in indexes_to_add:
                try:
                    quoted_fields = [qn(field) for field in fields]
                    fields_str = ', '.join(quoted_fields)
                    sql = f'CREATE INDEX IF NOT EXISTS {qn(index_name)} ON {qn(table)} ({fields_str})'
                    cursor.execute(sql)
                except Exception:
                    pass


def safe_remove_legacy_fields(apps, schema_editor):
    """Safely remove legacy VideoClip fields if they exist"""
    VideoClip = apps.get_model("workouts", "VideoClip")
    table = VideoClip._meta.db_table
    vendor = schema_editor.connection.vendor
    qn = schema_editor.quote_name
    
    # Define legacy fields to remove safely
    legacy_fields = ['type', 'url']
    
    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            def field_exists(field_name: str) -> bool:
                cursor.execute("""
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_name = %s AND column_name = %s
                """, [table.split('.')[-1], field_name])
                return cursor.fetchone() is not None

            for field_name in legacy_fields:
                if field_exists(field_name):
                    try:
                        cursor.execute("""
                            ALTER TABLE {qn(table)}
                            DROP COLUMN IF EXISTS {qn(field_name)}
                        """)
                    except Exception:
                        # Field may already be dropped or constraints prevent dropping
                        pass
        else:
            # SQLite doesn't support DROP COLUMN easily
            # These fields should have been handled during previous migrations
            pass


def safe_remove_legacy_index(apps, schema_editor):
    """Safely remove legacy VideoClip index if it exists"""
    VideoClip = apps.get_model("workouts", "VideoClip")
    table = VideoClip._meta.db_table
    vendor = schema_editor.connection.vendor
    
    legacy_index_name = 'video_clips_exercis_cde9f7_idx'
    
    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            # Check if index exists in PostgreSQL
            cursor.execute("""
                SELECT 1
                FROM pg_indexes
                WHERE tablename = %s AND indexname = %s
            """, [table.split('.')[-1], legacy_index_name])
            
            if cursor.fetchone():
                try:
                    cursor.execute(f'DROP INDEX IF EXISTS {legacy_index_name}')
                except Exception:
                    # Index may already be dropped or other issues
                    pass
        else:
            # SQLite - check if index exists  
            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='index' AND name = %s",
                [legacy_index_name]
            )
            
            if cursor.fetchone():
                try:
                    cursor.execute(f'DROP INDEX IF EXISTS "{legacy_index_name}"')
                except Exception:
                    # Index may already be dropped or other issues
                    pass


def safe_remove_legacy_exercise_fields(apps, schema_editor):
    """Safely remove legacy Exercise fields if they exist"""
    Exercise = apps.get_model("workouts", "Exercise")
    table = Exercise._meta.db_table
    vendor = schema_editor.connection.vendor
    qn = schema_editor.quote_name
    
    # Define legacy Exercise fields to remove safely
    legacy_fields = ['mistake_video_url', 'technique_video_url']
    
    with schema_editor.connection.cursor() as cursor:
        if vendor == "postgresql":
            def field_exists(field_name: str) -> bool:
                cursor.execute("""
                    SELECT 1
                    FROM information_schema.columns
                    WHERE table_name = %s AND column_name = %s
                """, [table.split('.')[-1], field_name])
                return cursor.fetchone() is not None

            for field_name in legacy_fields:
                if field_exists(field_name):
                    try:
                        cursor.execute("""
                            ALTER TABLE {qn(table)}
                            DROP COLUMN IF EXISTS {qn(field_name)}
                        """)
                    except Exception:
                        # Field may already be dropped or constraints prevent dropping
                        pass
        else:
            # SQLite doesn't support DROP COLUMN easily
            # These fields should have been handled during previous migrations
            pass


class Migration(migrations.Migration):

    dependencies = [
        ('workouts', '0015_merge_state_only_and_0012'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='weeklylesson',
            options={'ordering': ['week']},
        ),
        # Safe removal of legacy constraint (cross-platform)
        migrations.RunPython(
            safe_drop_weekly_lesson_constraint,
            reverse_code=migrations.RunPython.noop,
        ),
        # Safe removal of legacy index (may not exist in all databases)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.RemoveIndex(
                    model_name='videoclip',
                    name='video_clips_exercis_cde9f7_idx',
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    safe_remove_legacy_index,
                    reverse_code=migrations.RunPython.noop,
                ),
            ],
        ),
        # Safe removal of legacy Exercise fields (may not exist in production)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.RemoveField(
                    model_name='exercise',
                    name='mistake_video_url',
                ),
                migrations.RemoveField(
                    model_name='exercise',
                    name='technique_video_url',
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    safe_remove_legacy_exercise_fields,
                    reverse_code=migrations.RunPython.noop,
                ),
            ],
        ),
        # Safe addition of exercise fields (may already exist in production DB)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name='exercise',
                    name='equipment',
                    field=models.CharField(
                        default='bodyweight',
                        help_text='Основной инвентарь: bodyweight | dumbbell | barbell …',
                        max_length=50,
                    ),
                ),
                migrations.AddField(
                    model_name='exercise',
                    name='poster_image',
                    field=models.ImageField(
                        blank=True,
                        null=True,
                        help_text='Poster image for video player',
                        upload_to='photos/workout/',
                    ),
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    safe_add_exercise_columns,
                    reverse_code=migrations.RunPython.noop,
                ),
            ],
        ),
        # Safe addition of VideoClip fields (may already exist in production DB)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddField(
                    model_name='videoclip',
                    name='is_placeholder',
                    field=models.BooleanField(default=False),
                ),
                migrations.AddField(
                    model_name='videoclip',
                    name='playback_id',
                    field=models.CharField(blank=True, help_text='Stream playback ID', max_length=64, null=True),
                ),
                migrations.AddField(
                    model_name='videoclip',
                    name='provider',
                    field=models.CharField(choices=[('r2', 'Cloudflare R2'), ('stream', 'Cloudflare Stream'), ('external', 'External URL')], default='r2', help_text='Video storage provider', max_length=16),
                ),
                migrations.AddField(
                    model_name='videoclip',
                    name='r2_archetype',
                    field=models.CharField(blank=True, choices=[('peer', 'Ровесник'), ('professional', 'Успешный профессионал'), ('mentor', 'Мудрый наставник')], help_text='Archetype for R2 videos', max_length=20),
                ),
                migrations.AddField(
                    model_name='videoclip',
                    name='r2_file',
                    field=models.FileField(blank=True, help_text='Video file in R2 storage', null=True, upload_to='videos/'),
                ),
                migrations.AddField(
                    model_name='videoclip',
                    name='r2_kind',
                    field=models.CharField(choices=[('technique', 'Technique'), ('mistake', 'Common Mistake'), ('instruction', 'Instruction'), ('intro', 'Introduction'), ('weekly', 'Weekly Motivation'), ('closing', 'Closing'), ('reminder', 'Reminder'), ('explain', 'Exercise Explanation')], default='instruction', help_text='Video type for R2 organization', max_length=20),
                ),
                migrations.AddField(
                    model_name='videoclip',
                    name='script_text',
                    field=models.TextField(blank=True, help_text='Video script or content'),
                ),
                migrations.AddField(
                    model_name='videoclip',
                    name='stream_uid',
                    field=models.CharField(blank=True, help_text='Cloudflare Stream UID', max_length=64, null=True),
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    safe_add_videoclip_columns,
                    reverse_code=migrations.RunPython.noop,
                ),
            ],
        ),
        migrations.AlterField(
            model_name='exercise',
            name='created_at',
            field=models.DateTimeField(auto_now_add=True, null=True),
        ),
        migrations.AlterField(
            model_name='exercise',
            name='updated_at',
            field=models.DateTimeField(auto_now=True, null=True),
        ),
        migrations.AlterField(
            model_name='finalvideo',
            name='arch',
            field=models.CharField(choices=[('111', 'Н'), ('222', 'П'), ('333', 'Р')], max_length=3, primary_key=True, serialize=False),
        ),
        migrations.AlterField(
            model_name='videoclip',
            name='archetype',
            field=models.CharField(choices=[('peer', 'Ровесник'), ('professional', 'Успешный профессионал'), ('mentor', 'Мудрый наставник')], max_length=20),
        ),
        migrations.AlterField(
            model_name='weeklylesson',
            name='archetype',
            field=models.CharField(choices=[('111', 'Н'), ('222', 'П'), ('333', 'Р')], max_length=3),
        ),
        migrations.AlterField(
            model_name='weeklylesson',
            name='duration_sec',
            field=models.PositiveIntegerField(default=180, help_text='Estimated reading time in seconds'),
        ),
        migrations.AlterField(
            model_name='weeklylesson',
            name='id',
            field=models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID'),
        ),
        migrations.AlterField(
            model_name='weeklylesson',
            name='week',
            field=models.PositiveSmallIntegerField(),
        ),
        migrations.AlterUniqueTogether(
            name='weeklylesson',
            unique_together={('week', 'archetype', 'locale')},
        ),
        # Safe alteration of VideoClip unique constraint (may not exist in production)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AlterUniqueTogether(
                    name='videoclip',
                    unique_together={('exercise', 'r2_kind', 'r2_archetype', 'model_name', 'reminder_text')},
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    safe_alter_videoclip_unique_together,
                    reverse_code=migrations.RunPython.noop,
                ),
            ],
        ),
        # Safe addition of VideoClip indexes (may already exist in production)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.AddIndex(
                    model_name='videoclip',
                    index=models.Index(fields=['exercise', 'r2_kind', 'r2_archetype'], name='video_clips_exercis_1e5613_idx'),
                ),
                migrations.AddIndex(
                    model_name='videoclip',
                    index=models.Index(fields=['r2_kind', 'r2_archetype'], name='video_clips_r2_kind_d2e4dd_idx'),
                ),
                migrations.AddIndex(
                    model_name='videoclip',
                    index=models.Index(fields=['is_active', 'r2_kind'], name='video_clips_is_acti_9705f9_idx'),
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    safe_add_videoclip_indexes,
                    reverse_code=migrations.RunPython.noop,
                ),
            ],
        ),
        # Safe removal of legacy fields (may not exist in production)
        migrations.SeparateDatabaseAndState(
            state_operations=[
                migrations.RemoveField(
                    model_name='videoclip',
                    name='type',
                ),
                migrations.RemoveField(
                    model_name='videoclip',
                    name='url',
                ),
            ],
            database_operations=[
                migrations.RunPython(
                    safe_remove_legacy_fields,
                    reverse_code=migrations.RunPython.noop,
                ),
            ],
        ),
        migrations.RunPython(
            set_provider_for_existing_clips,
            reverse_set_provider,
        ),
    ]
